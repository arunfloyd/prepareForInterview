Mongo DB

 ◦ Collection :
    - A collection is a grouping of documents.

 ◦ CRUD : 
     - CRUD operations in MongoDB refer to the basic methods used to interact with a MongoDB database.

        - Create: Insert new documents into the MongoDB database. (insertOne,insertMany)
        - Read: Query and retrieve documents from the database. (find,aggregate)
        - Update: Modify existing documents in the database. (updateOne,updateMany,replaceOne)
        - Delete: Remove documents from the database. (deleteOne,deleteMany)

 ◦ Lookup :
      - The $lookup stage in MongoDB performs a left outer join to a collection in the same database.
      - It filters in documents from the "joined" collection for processing.

        - Eg: {
               $lookup: {
               from: <collection to join>,
               localField: <field from the input documents>,
               foreignField: <field from the documents of the "from" collection>,
               as: <output array field> or Alias
               }
             }

 ◦ Unwind :
     - Used to deconstruct an array field from the input documents and create a separate output document 
       for each element in the array

 ◦ In :
     - Used to select documents where the value of a field equals any value in the specified array.
       
       - Syntax : { field: { $in: [<value1>, <value2>, ... <valueN>] } }
       - Eg : db.student.find({language: {$in: ["JavaScript", "CSS"]}}).pretty()
       - In this example, we are retrieving the data of students working with either JavaScript or CSS.

 ◦ Capped collection :
      - Capped collections in MongoDB are fixed-size collections that support high-throughput operations based on insertion order.

      * Capped collections automatically remove the oldest documents to make room for new ones.
      * They have an _id field and an index on the _id field by default.
      * They do not support updates or document deletions, and you cannot shard a capped collection.

    
 ◦ Alias :
      - An Alternative name given to a field in a document within a collection. 
      - Aliases allow you to create temporary field names within aggregation pipelines without modifying the original document structure.

 ◦ Mongo Utilities
      - Tools to help developers manage databases, perform operations, and optimize performance

          - mongodump and mongorestore: These utilities are used for creating backups of MongoDB databases and restoring them.
          - mongoexport and mongoimport: These utilities are used for importing and exporting data in JSON, CSV, or TSV format.
          - mongostat: This utility provides a quick overview of the status of a MongoDB instance, including metrics like connections,
                       operations, memory usage, and more.

 ◦ Indexing :
     - Indexes support efficient execution of queries by allowing MongoDB to limit the number of documents it must scan.
     - Without indexes, MongoDB would need to scan every document in a collection to return query results.
     
            - Single Field Index: Index created on a single field.
            - Compound Index: Index created on multiple fields.
            - Multikey Index: Index used to index content stored in arrays.
            - Geospatial Index : Index created on coordinate system


 ◦ Logical operator :
     - Constructing conditional statements and filtering data based on specific criteria

        - AND 
          - The and operator is used to combine two or more conditions in a way that all conditions must be true for the overall expression to be true.
          - Example: if (condition1 && condition2) { // do something }
        - OR 
          - The or operator is used to combine two or more conditions in a way that at least one of the conditions must be true for the overall expression to be true. 
          - Example: if (condition1 || condition2) { // do something }
        - NOT 
         - The nor operator is a logical operator that combines two conditions and returns true only if both conditions are false.
         - Example: if (!(condition1 || condition2)) { // do something }
        - NOR
         - The nor operator is a logical operator that combines two conditions and returns true only if both conditions are false.
         - Example: if (!(condition1 || condition2)) { // do something }

 ◦ Comparison operator : 
     - Allow developers to compare values within documents and collections to retrieve specific data based on defined criteria.

       - lt (less than): 
        - Example: db.collection.find({ field: { $lt: value } })
       - gt (greater than)
       - eq (equal)
       - ne (not equal):


 ◦ Namespace :
     - Namespaces are used to organize and access data efficiently. 
     - The format of a namespace is <database_name>.<collection_name>

 ◦ addtoSet():
     - Add a value to an array field if the value is not already present. 
     - If the value is already in the array, the addToSet operation does not modify the array.

 ◦ Sharding :
     - Enables efficient data distribution, scalability, and performance in handling large and growing datasets

 ◦ Insert vs save
    - Insert :
       - Used to insert a new document or multiple documents into a collection.
    - Save :
       - Used to insert a new document or update an existing document in a collection.  
       - If the document being saved already contains an _id field, the save operation will update the existing document with the same _id.

 ◦ BSON
    - It stands for Binary JSON, is a binary-encoded serialization of JSON-like documents used in MongoDB and other systems.
    - It is designed to be lightweight, traversable, and efficient for storage and data exchange.

 ◦ Data type
    - String: Used to store textual data.
    - Integer: Represents whole numbers.
    - Double: Represents floating-point numbers.
    - Boolean: Stores true or false values.
    - Date: Represents date and time values.
    - Array: Stores an ordered list of values.
    - Object: Represents embedded documents.
    - Null: Represents a null value.
    - Binary Data: Stores binary data.
    - ObjectId: A unique identifier for documents.
    - Timestamp: Stores timestamp values.
    - Decimal128: Represents decimal numbers.
    - Min Key: Represents the smallest possible value.
    - Max Key: Represents the largest possible value.

 ◦ Update operators
    - Set :
       - The $set operator is used to update the value of a field or create a new field if it does not exist.
    - Unset :
       - The $unset operator is used to remove a field from a document.
    - Inc : 
       - The $inc operator is used to increment the value of a field by a specified amount.
   
 ◦ Distinct :
    - Find the unique values for a specified field across a single collection

 ◦ Accumulators :
   - To maintain state as documents progress through the pipeline. Eg:- max min sum avg

 ◦ Count :
   - To determine the number of documents that match a specified query within a collection

 ◦ Out :
   - Used in the context of the aggregation framework to specify the destination collection where the results
     of an aggregation operation should be written to.
   - It allows the results of an aggregation pipeline to be stored in a new or existing collection.

 ◦ findOneAndUpdate : 
   - This method allows you to update a single document based on specified criteria and retrieve either the original or updated document.

 ◦ Replication :
  - The process of synchronizing data across multiple servers to ensure high availability, fault tolerance, and data redundancy.
  - It involves maintaining multiple copies of data on different servers, known as replica set members, 
    to provide resilience against hardware failures and to enable read scaling.
  - A replica set is a group of MongoDB servers that maintain the same data set, with one primary node and multiple secondary nodes. 
  - The primary node is the main read-write node that receives all write operations and replicates the data to the secondary nodes.
  - Secondary nodes are read-only copies of the data that replicate changes from the primary node. 
  - In the event of a primary node failure, replica sets support automatic failover, 
    where one of the secondary nodes is automatically elected as the new primary node to ensure continuous operation.

 ◦ Aggregation :
  - Aggregation in MongoDB is a powerful feature that allows you to process and analyze data across multiple documents in a collection.
  - It involves using aggregation pipelines to perform operations such as grouping, filtering, sorting, and transforming data to generate meaningful results
    * An aggregation pipeline is a series of stages that process documents.
    - Common stages include $match, $group, $sort, $project, $limit, and $lookup.
    * MongoDB provides a wide range of aggregation operators to perform specific tasks within the pipeline.
    - Operators like $sum, $avg, $group, $match, $project, and $sort are commonly used for aggregation operations.

 > Sql vs No-Sql
  * SQL Databases: 
  - SQL, or Structured Query Language, is a language used to manage and manipulate data in relational database management systems (RDBMS). 
  - SQL databases are based on a structured schema, typically using tables with rows and columns,
    and are known for their ability to handle complex queries and transactions
  * NoSQL Databases: 
  - NoSQL databases, on the other hand, are non-relational databases that offer more flexibility in handling unstructured and semi-structured data.
  - They are designed to scale horizontally and are often used in modern, distributed systems.

 > Cursor
  - In MongoDB, when you perform a read operation using methods like db.collection.find(), the result is returned as a cursor.
  - Fetching and processing query results in MongoDB, providing a flexible and efficient way to work with large datasets and perform data operations.

 > upsert
  - Upsert is a database operation that combines the actions of insert and update.
  - When performing an upsert operation, the system will insert a new document if no matching document is found based on a specified filter criteria
  - Eg:
       db.collection.updateOne(
       { name: "Alice" }, // Filter criteria
       { $set: { age: 30 } }, // Update operation
       { upsert: true } // Upsert option
       ) 
   
 > CAP theorem
  - In distributed systems that states that it is impossible for a distributed data store to simultaneously provide more than two out of the
    following three guarantees:
    - Consistency: All nodes in the system have the same data at the same time.
    - Availability: The ability of the system to respond to requests even in the presence of faults.
    - Partition Tolerance: The system's ability to function and maintain data consistency even when network partitions occur.

 > Views
  - Is a read-only queryable object whose contents are defined by an aggregation pipeline on other collections or views.
  - They provide a way to create a virtual collection that presents the results of the aggregation pipeline as a collection. 

 > Embedded object :
  - Embedded object refers to a document or subdocument that is nested within another document. 

 > allowdiskuse :
  - Method to allow the aggregation pipeline to write data to temporary files on disk if the pipeline stages consume more than 100 megabytes of RAM.

 > vertical and horizontal scaling
  * Vertical Scaling (Scaling Up): 
   - Vertical scaling involves increasing the capacity of a single server or node by adding more resources, such as CPU, memory, or storage, to the existing system.
  * Horizontal Scaling (Scaling Out):
   - Horizontal scaling involves adding more nodes or servers to a system to distribute the load and increase capacity.
   
 > atlas
  - MongoDB Atlas simplifies the process of managing MongoDB databases in the cloud, providing a reliable and scalable solution
    for modern applications that require a flexible and robust database infrastructure.

 > trigger
  - Trigger is a piece of server-side logic that automatically responds to specific database events, such as when a document is inserted, updated, or removed.
  - Triggers can be used to implement complex data interactions and automate tasks based on changes in the database.
  - They are commonly used to enforce data consistency, perform data validation, and execute custom business logic in response to database events.

 > GridFS
  - GridFS is a specification for storing and retrieving large files in MongoDB.
  - It is a way to store files that exceed the BSON document size limit of 16 MB by dividing them into smaller chunks
    and storing each chunk as a separate document in a collection.
  - GridFS is commonly used for storing and managing files such as images, videos, audio files, and other large binary data in MongoDB.

 > bitwise operator
  - Bitwise operators are used to perform bitwise operations on integer values within the database.
  - These operators allow you to manipulate individual bits of integer values, which can be useful for various bitwise operations such as setting,
    clearing, or toggling specific bits within a field.

  * The `bit` operator is used to perform bitwise AND, OR, and XOR operations on integer fields in the documents of a collection. 
    - It allows you to update specific bits of integer fields based on a given bitmask  

     - Eg:- 
        db.collection.updateMany(
                      { _id: 1 },
                      { $bit: { field: { and: 5, or: 3, xor: 6 } } }
                                 )
  * Bitwise Query Operators: MongoDB also provides bitwise query operators, such as $bitsAllSet, $bitsAnySet, and $bitsAllClear,
                             which allow you to query documents based on the presence or absence of specific bits in integer fields.
     - Eg :- 
        db.collection.find({ field: { $bitsAllSet: 5, $bitsAllClear: 3 } })         
        
                         
Javascript


 ✓ DOM
 ✓ CDN vs Download
 ✓ Event Listener
 ✓ Closure
 ✓ Scope and types of scope
 ✓ Hoisting
 ◦ Array methods
 ◦ Array cloning
 ◦ Spread operator
 ◦ Map, for each and reduce()
 ◦ Filter 
 ◦ Callback
 ◦ String methods
 ◦ Callback hell
 ◦ Currying
 ◦ Memoization
 ◦ Promise , promise methods
 ◦ Arrow function
 ◦ Types of conversion - int, parse
 ◦ Conditional statement
 ◦ Prototype
 ◦ Instance()
 ◦ Class , object, object methods
 ◦ Object destructuring
 ◦ Variable typing
 ◦ Event Loop
 ◦ Call stack
 ◦ Global Execution context
 ◦ Rest 
 ◦ Spread 
 ◦ Call 
 ◦ Apply 
 ◦ Bind
 ◦ Shadowing
 ◦ This
 ◦ IIFE
 > undifined vs not difined vs null
 > fisrt class fn
 > post and pre increment
 > bracket notation
 > template literals
 > try catch
 > pure order fn
 > session vs local vs cookies
 > call by value vs call by refrence
 > recursive fn
 > primitive and non primitive
 > temporal dead zone
 > higher order fn
 > async await 
 > this keyword
 > concat
 > identifier
 > escape seaquence
 > 

Node, Express


 ◦ Patch & put
   - GET: The GET method is used to retrieve data from the server.
          It is a read-only method, meaning it does not change or mutate data on the server.
          GET requests are safe and idempotent, making them suitable for fetching data. 

   - POST: POST is used to create new resources on the server.
           It is commonly used to create subordinate resources under a parent resource.
           POST requests are not idempotent and are suitable for non-idempotent operations    

   - PUT: PUT is primarily used for updating existing resources on the server.
          When making a PUT request, the entire resource is replaced with the new representation provided in the request body.
          PUT requests are idempotent but not safe    

   - PATCH: PATCH is used to modify existing resources by sending a set of instructions describing how the resource should
            be changed.
            Unlike PUT, PATCH does not require sending the entire resource representation, only the changes.
            PATCH requests are not idempotent. 

   - DELETE: The DELETE method is used to delete a specific resource identified by its URI.
             It removes the resource from the server.
             DELETE requests are idempotent, meaning multiple calls to delete the same resource will have the same result    

 ◦ Idempotence : 

   - Idempotence is a property of certain operations or API requests that ensures repeating the operation multiple times
     will yield the same result as if it was executed only once.
   - This principle is especially vital in distributed systems and APIs, as it helps maintain consistency and
     predictability in situations such as network issues, request retries, or duplicated requests.  

       - GET, PUT, DELETE, HEAD, OPTIONS, and TRACE are idempotent.
       - POST and PATCH are generally non-idempotent.  

 ◦ Option Method :

   - OPTIONS method is used to query a server about the HTTP methods and other options that are supported for a specific resource.
   - It is a useful tool for clients to understand the capabilities of a server and to make informed requests.
      Eg:  
           Here is an example of an OPTIONS request:
           OPTIONS /resource HTTP/1.1
           Host: example.com

           And a possible response from the server:
           HTTP/1.1 200 OK
           Allow: GET, POST, PUT, DELETE

 ◦ Middlewares
  - Middleware functions are essential components that have access to the request object (req), the response object (res),
    and the next middleware function in the application's request-response cycle.
     * Types :
       - Application-level Middleware
           - CORS Middleware
           - Authentication Middleware
       - Router-level Middleware
       - Error-handling Middleware
       - Built-in Middleware
       - Third-party Middleware 

 ◦ Set-immediate
    - The setImmediate function is used to schedule the immediate execution of a callback after the I/O events callbacks 
      and before setTimeout and setInterval.

      Eg:- setImmediate(() => {
           console.log('This will be executed in the next iteration of the event loop');
           });

 ◦ Events :
  - Events in Node.js are a fundamental part of its asynchronous, event-driven architecture.
  - In Node.js, every action is considered an event, such as when a connection is made or a file is opened.
  - Objects in Node.js can emit events, and developers can create, fire, and listen for their own events using 
    the built-in "Events" module.
 
 ◦ Session and cookie
  - Session and cookie management are essential aspects of web development, particularly when building stateful
    and secure web applications.
    Both sessions and cookies are used to maintain user state and identity across multiple requests 
    and are integral to user authentication, personalization, and tracking.
     - Cookies: Cookies are small pieces of data stored in the user's browser. 

 ◦ View engine
  - A view engine is a templating engine that allows you to generate dynamic HTML content by combining static templates with data.
  - Express supports various view engines like EJS, Pug (formerly Jade), Handlebars, and Mustache.

 ◦ status code
  - A status code in the context of web development refers to a three-digit numeric code that is sent by a server in response to a client's request.

     - 1xx: Informational responses
     - 2xx: Success responses
     - 3xx: Redirection responses
     - 4xx: Client error responses
     - 5xx: Server error responses

 ◦ Cors in detail
  - Cross-Origin Resource Sharing, is a security feature implemented in web browsers to control how web pages or web applications on one domain
    can access resources from another domain.
  - It is a critical security mechanism that helps prevent unauthorized access to resources and protects against cross-site request forgery (CSRF) attacks.
 
 ◦ Body parser : 
  - Body parser is a middleware module for Node.js that is used to parse incoming request bodies in a middleware
    before your handlers, available under the req.body property.
  - It simplifies the process of handling data sent in HTTP requests by parsing the request body 
    and populating the req.body object with the parsed data.

 ◦ Morgan
  - Morgan is a popular HTTP request logger middleware for Node.js.
  - It provides a simple and flexible way to log HTTP requests and responses in Node.js applications.
  - By using Morgan, developers can easily log requests made to their Node.js server, including information 
    such as the request method, URL, status code of the response, and the length of the response body

 ◦ NPM
  - NPM plays a crucial role in the Node.js ecosystem, providing a centralized repository for packages 
    and tools that enhance the development experience for Node.js developers.

 ◦ PM2 
  - PM2 is a popular process manager for Node.js applications that simplifies process management, 
    monitoring, and deployment in production environments.
  - It provides a robust set of features to ensure that Node.js applications run smoothly and efficiently.

 ◦ Postman
  - Postman is a popular collaboration platform for API development that simplifies the process of designing,
    testing, and documenting APIs.
  - It provides a user-friendly interface for sending HTTP requests, testing API endpoints, and managing API collections.
 
 ◦ Types of errors
  - Syntax Errors 
  - Runtime Errors
  - Logical Errors

 ◦ app.use
  - The app.use function in Express is a fundamental part of setting up middleware for handling requests.
  - It is used to mount the specified middleware function or functions at the specified path.
  - This function can take various forms, allowing for flexibility in how middleware is applied to the application

 ◦ MVC
  - MVC (Model-View-Controller) is a software architecture pattern commonly used in web development to organize 
    and structure applications.

 ◦ Child process
  - Child processes in Node.js are a powerful feature that allows developers to spawn and manage subprocesses,
    enabling parallel execution of tasks and interaction with external processes.
  - The child_process module in Node.js provides a range of methods for creating and interacting with child processes,
    including spawn, exec, execFile, and fork.

  - The child_process.spawn() method is commonly used to launch a new process, providing options for passing arguments
    and interacting with the standard input/output streams of the child process.
  - This method is asynchronous and does not block the Node.js event loop, making it suitable for non-blocking operations.

 > node,why
  - Node.js is an open-source, cross-platform JavaScript runtime environment that allows developers to execute JavaScript
    code outside of a web browser.
  - It is built on Google Chrome's V8 JavaScript engine and is designed to be lightweight, efficient, and scalable.
  - Node.js is widely used for server-side programming and is particularly well-suited for building networked
    and real-time applications.
 
 > modules
  - modules are a fundamental aspect of structuring and organizing code.
   They allow developers to encapsulate functionality into reusable units, making it easier to manage
   and maintain complex applications.
    - Built-in Modules: http, fs, and path
    - Local Modules : custom modules created by developers
    - Third-party Modules : Npm , yarn

 > node global object
  - The global object in Node.js is similar to the window object in web browsers, but it is specific to the Node.js environment.
  - It provides access to global properties, such as process, console, Buffer, and require, 
    as well as global functions like setTimeout, clearTimeout, setInterval, and clearInterval.

 > json
  - JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines 
    to parse and generate.
  - It is based on a subset of the JavaScript programming language and is commonly used for transmitting data between a server and
    a web application as an alternative to XML.

 > streams
  - Streams in Node.js are a fundamental concept that allows developers to work with streaming data efficiently.
  - A stream is an abstract interface for working with streaming data in Node.js, and it provides a way to handle data piece by piece or in chunks,
    rather than loading the entire dataset into memory at once.
      
      - Readable: Streams from which data can be read.
      - Writable: Streams to which data can be written.
      - Duplex: Streams that are both Readable and Writable.
      - Transform: Duplex streams that can modify or transform the data as it is written and read. 

 > techniques used for streams(piping and chaining)
  - Piping involves connecting the output of one stream to the input of another stream, creating a data flow pipeline.
  - Piping simplifies the process of transferring data between streams without manually handling data chunks and buffering.

  - Chaining involves connecting multiple streams in a sequence to create a chain of stream operations.
  - Chaining allows for complex data processing workflows by connecting streams one after another.

 > libuv
  - Libuv is a multi-platform support library in C that provides asynchronous I/O operations, networking, and other fundamental functionalities for Node.js.
  - It serves as the underlying technology that enables Node.js to achieve its asynchronous and event-driven nature, 
    allowing for efficient handling of I/O operations without blocking the main thread.

 > api
  - Application Programming Interface, is a set of rules and protocols that allows different software applications to communicate with each other.
  - APIs define the methods and data formats that applications can use to request and exchange information.
  
 > logger 
  - Logging is a crucial aspect of software development, especially in Node.js applications, to track and monitor the behavior of the application.
  - A logger is a component or module used to record events, errors, and other information during the execution of a program.
  - It helps developers troubleshoot issues, analyze performance, and gain insights into the application's behavior. 

 > https 
  - Module provides functionality to create secure HTTPS servers and make secure HTTPS requests.
  - It is an essential part of building secure web applications and APIs in Node.js.

 > nodemon
  - Nodemon is a command-line interface (CLI) utility for Node.js that is designed to automatically restart Node.js applications 
    when file changes are detected.
  - This eliminates the need to manually stop and restart the server each time changes are made to the code,
    which can significantly improve the development workflow.

 > thread pool
  - The thread pool in Node.js plays a crucial role in offloading synchronous and heavy-duty tasks from the main event loop,
    thereby enhancing the performance, scalability, and responsiveness of Node.js applications.

 > util
  - In Node.js, the util module provides a set of utility functions that are helpful for various tasks such as debugging, error handling,
    and working with objects.
  - It contains several sub-modules and functions that are commonly used in Node.js applications

 > zlib
 - The zlib module provides compression and decompression functionalities through various compression algorithms.
 - It allows you to work with compressed data streams, which can be useful for reducing file sizes, transmitting data more efficiently over networks,
   or storing data in a compressed format.

 > payload
  - The data transmitted over a network or passed between systems as part of a communication protocol.
  - The payload is the actual content or information being sent, as opposed to the headers, metadata, or other overhead that may accompany it.

 > TLS
  - Transport Layer Security is a cryptographic protocol used to secure communications over a computer network.
  - It ensures that data transmitted between two parties, such as a client and a server, remains private, authenticated, and tamper-proof.
  - TLS is the successor to the earlier SSL (Secure Sockets Layer) protocol.




DS 1
 > application af LL,elc...
 > LL O(n)
 > what is ds
 > linear vs non linear ds
 > types of ds
 > algorithm
 > complexity analysis
 > asymptotic analysis and notation
 > memory allocation
 > types of memory allocation
 > contiguous and non contiguous
 > memory leaks
 > garbage collection and its working
 > when garbage collector fails
 > cicular LL
 > doubly LL
 > recursion 
 > adv and disadv
 > mutable and immutable string
 > heirarchal DS
 > jagged array
 > 
 

DS 2
 > bubble sort O(n^2)
 > insertion sort O(n^2)
 > selection sort O(n^2)
 > quick sort O(nlog n),O(n^2)worst case
 > merge sort O(nlog n)
 > stack(lifo)
 > queue(fifo)
 > peek
 > application of queue and stack
 > stable and unstable 
 > deterministic and non deterministic
 > types of queue and stack
 > satck underflow vs stack overflow
 > divide and conquer strategy
 > hashtable,application
 > pros of LL using for stack and queue
 > double ended queue
 > hash fn,types
 > hash value
 > collision
 > methods to prevent collission
 > chaining,linear probing,quadratic,double hashing
 > load factor
 > array vs hashtable


DS 3

 > tree,application
 > complete,full,perfect tree
 > bst O(log n)
 > heap O(log n)
 > types of graph
 > isolated vertex
 > weighted graph 
 > heapsort O(n)
 > trie vs hashtable
 > graph indexing
 > vertex indexing
 > edge indexing
 > heigth vs depth of a node
 > degree of a node
 > shortest path algorithm
 > binomeal heap
 > BFS and DFS
 > self balancing tree
 > topdown and bottomup heapification
 > how to check bst is a subset of x
 > adv of priority queue using heap
 > adjecency list and adjecancy matrix
 > graph , application ,types
 > BST , application ,type
 > trie application ,type
 > heap , application , type